/*
В Самую Секретную Военную Часть под командованием полковника Покрышкина приехал с проверкой генерал из Министерства Обороны. По этому случаю полковник приказал всем n солдатам из своей Части построиться на плацу.

Согласно военному уставу, солдаты должны стоять в порядке невозрастания их роста, но так как времени на построение совсем не осталось, то солдаты выстроились в произвольном порядке. Однако у генерала весьма плохое зрение, и поэтому он считает, что солдаты построены правильно, если самый первый в строю — солдат с максимальным ростом, а самый последний — солдат с минимальным ростом. Обратите внимание, что неважно то, как расположены остальные солдаты, в том числе и в случае нескольких максимальных или минимальных по росту солдат. Важны лишь росты первого и последнего солдата.

Например, генерал считает последовательность ростов (4, 3, 4, 2, 1, 1) правильной, а последовательность (4, 3, 1, 2, 2) — нет.

За одну секунду полковник может обменять местами любых двух соседних солдат. Помогите ему подсчитать, какое минимальное количество секунд понадобится, чтобы получившийся строй понравился генералу.

Входные данные
Первая строка входных данных содержит единственное целое число n (2 ≤ n ≤ 100) — количество солдат в строю. Вторая строка содержит целые числа a1, a2, ..., an (1 ≤ ai ≤ 100) — величины ростов солдат в порядке от начала строя к концу. Числа разделены пробелом. Числа a1, a2, ..., an не обязательно различны.

Выходные данные
Выведите единственное целое число — какое минимальное количество секунд понадобится полковнику, чтобы получившийся строй понравился генералу.

Примеры
входные данные
4
33 44 11 22
выходные данные
2
входные данные
7
10 10 58 31 63 40 76
выходные данные
10
*/

import java.util.Scanner;

public class Task144A {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] growth = new int[n];
		int max = -1;
		int min = 101; 
		int imin = 0;
		int imax = 0;
		for (int i = 0; i < growth.length; i++) {
			growth[i] = sc.nextInt();
			if (growth[i] <= min) {
				min = growth[i];
				imin = i;
			}
			if (growth[i] > max) {
				max = growth[i];
				imax = i;
			}
		}
		int sum = 0;
		if (imax > imin) {
			sum = (n - 1 - imin) + imax - 1;
		} else {
			sum = (n - 1 - imin) + imax;
		}
		System.out.println(sum);
	}
}
