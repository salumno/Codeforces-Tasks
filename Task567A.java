/*
Все города Лайнландии расположены на координатной прямой Ox. Таким образом, каждый город характеризуется своим положением xi — координатой на оси Ox. Никакие два города не расположены в одной точке.

Жители Лайнландии очень любят слать друг другу письма. Житель страны может отослать письмо другому жителю только в том случае, если адресат живёт в другом городе (так как если они живут в одном городе, то им проще ходить в гости).

Удивительно, но факт: стоимость отправки письма в точности равна расстоянию между городом отправителя и городом получателя.

Для каждого города найдите два значения mini и maxi, где mini — минимальная стоимость отправки письма из i-го города в какой-либо другой город, а maxi — максимальная стоимость отправки письма из i-го города в какой-либо другой город.

Входные данные
В первой строке входных данных содержится целое число n (2 ≤ n ≤ 105) — количество городов в Лайнландии. Во второй строке содержится последовательность из n различных целых чисел x1, x2, ..., xn ( - 109 ≤ xi ≤ 109), где xi — x-координата i-го города. Все xi различны и идут в порядке возрастания.

Выходные данные
Выведите n строк, i-я строка должна содержать два целых числа mini, maxi, разделённых пробелом, где mini — минимальная стоимость отправки письма из i-го города, а maxi — максимальная стоимость отправки письма из i-го города.

Примеры
входные данные
4
-5 -2 2 7
выходные данные
3 12
3 9
4 7
5 12
входные данные
2
-1 1
выходные данные
2 2
2 2
*/

import java.util.Scanner;

public class Task567A {
	
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] city = new int[n];
		for (int i = 0; i < n; i++) {
			city[i] = sc.nextInt();
		}
		for (int i = 0; i < n; i++) {
			int min;
			int max;
			if (i == 0) {
				min = Math.abs(city[0] - city[1]);
				max = Math.abs(city[0] - city[n-1]);
			} else {
				if (i == n-1) {
					min = Math.abs(city[n-1] - city[n-2]);
					max = Math.abs(city[0] - city[n-1]);
				} else {
					min = Math.min(Math.abs(city[i] - city[i-1]), Math.abs(city[i] - city[i+1]));
					max = Math.max(Math.abs(city[i] - city[0]), Math.abs(city[i] - city[n-1]));
				}
			}
			System.out.println(min + " " + max);
		}
	}
}
